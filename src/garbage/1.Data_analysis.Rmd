---
title: "CATS function complete"
author: "Jelyn Gerkema"
date: "2023-05-01"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Set up 

```{r set up}

source("src/settings.R")
source("src/functions.R")
source("src/maxent2.R")
source("src/maxenttest2.R")
source("src/trait_information.R")

load("data/processed/Bio_exp_processed.RData")

```

## 2. Running the model 

### 2.1 Setting up multiple cores

```{r setting up cores}

#Determines amount of cores, substract four to keep to pc free for other processes.
n_cores <- parallel::detectCores() - 4 

my_cluster <- makeSOCKcluster(n_cores)

registerDoSNOW(cl = my_cluster)

foreach::getDoParRegistered() # check if cluster is set up

```

### 2.2 Running the CATS model

```{r actually runnin the model}
input_names <- c("processed_specieslvl", "processed_genuslvl", "processed_familylvl")
input_list <- lst(processed_specieslvl, processed_genuslvl, processed_familylvl)

output_list <- list()

for(i in input_names){
  
  input <- input_list[[i]]
  
  meta_prior <- as.matrix(input[["relative_abundances"]][["matrix4traits"]]) %>%
  t() %>%
  as.data.frame() %>%
  mutate(Total_cover = rowSums(.)) %>%
  select(Total_cover) %>%
  mutate(Relative_meta_cover = Total_cover / sum(Total_cover)) %>%
  as.data.frame() %>%
  pull(Relative_meta_cover)
  
  states <- input[["trait_species_match"]] %>%
  column_to_rownames("Name") %>%
  t() %>%
  as.data.frame()

  plot_code_vector <- input[["calculations_cwm_cwv"]] %>% pull(Plot_code)
  
  pb <- progress::progress_bar$new(
    format = "(Plot (n) = :Plot [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
    total = length(plot_code_vector),
    complete = "=", 
    incomplete = "-", 
    current = ">", 
    clear = FALSE, 
    width = 100
  ) 

plot_n <- 1:length(plot_code_vector)
  
progress <- function(n) {
  pb$tick(tokens = list(Plot = plot_n[n]))
  }

opts <- list(progress = progress)

cats_output <- foreach(
  plot = plot_code_vector, .combine = "rbind", .options.snow = opts,
  .packages =
  list_of_packages
  ) %dopar% {
    
    constraints_temp <- input[["calculations_cwm_cwv"]] %>%
      subset(Plot_code %in% plot) %>%
      select(all_of(cwm_names))

    relative_cover_temp <- input[["relative_abundances"]][["matrix4traits_prop"]] %>%
      as.data.frame() %>%
      subset(rownames(.) %in% plot)

    # calculating model using the community-weighted trait plus a uniform prior...
    fit1 <- maxent2(constr = constraints_temp, states = states, lambda = TRUE)
    temp1 <- maxent.test2(model = fit1, obs = relative_cover_temp, nperm = 99, quick = FALSE)

    # Extract the lambda values
    lambda_fit1 <- list(fit1$lambda) %>%
      as.data.frame(col.names = c("Lambda_fit1")) %>%
      rownames_to_column(var = "Trait") %>%
      mutate(Trait = paste(Trait, "fit1")) %>%
      pivot_wider(names_from = "Trait", values_from = "Lambda_fit1")

    # an ESTIMATE (using 99 permutations) of model bias (model.mean.null.given.uniform)
    model.mean.null.given.uniform <- temp1$mean.KLR2.null
    model.bias <- model.mean.null.given.uniform

    # model fit using the CWM and only the uniform prior...
    model.uniform.prior.plus.traits <- temp1$KLR2.prior.plus.traits

    # if the model using the maximally uninformative prior plus traits is less than the
    # model bias, then correct...
    if (model.uniform.prior.plus.traits < model.bias) {
      model.uniform.prior.plus.traits <-
        model.bias
    }

    # calculating model using the CWM plus neutral prior
    fit2 <- maxent2(constr = constraints_temp, states = states, prior = meta_prior, lambda = TRUE)
    temp2 <- maxent.test2(model = fit2, obs = relative_cover_temp, nperm = 99, quick = FALSE)

    # Extract the lambda values
    lambda_fit2 <- list(fit2$lambda) %>%
      as.data.frame(col.names = c("Lambda_fit2")) %>%
      rownames_to_column(var = "Trait") %>%
      mutate(Trait = paste(Trait, "fit2")) %>%
      pivot_wider(names_from = "Trait", values_from = "Lambda_fit2")

    model.mean.null.given.prior <- temp2$mean.KLR2.null

    # if this null, given the neutral prior, is less than the mean given the maximally
    # uniformative prior, then correct...
    if (model.mean.null.given.prior < model.bias) {
      model.mean.null.given.prior <-
        model.bias
    }

    # fit using the CWM and the neutral prior...
    model.prior.plus.traits <- temp2$KLR2.prior.plus.traits

    # if this model, given the neutral prior and the traits, is less than the fit of the model using
    # the maximally uniformative prior and the traits, then correct...
    if (model.prior.plus.traits < model.uniform.prior.plus.traits) model.prior.plus.traits <- model.uniform.prior.plus.traits


    all_KLR2 <- cbind(
      model.bias, model.uniform.prior.plus.traits,
      model.mean.null.given.prior, model.prior.plus.traits, model.mean.null.given.uniform,
      lambda_fit1, lambda_fit2
    ) %>%
      as.data.frame() %>%
      mutate(Plot_code = plot)

    gc()
    
    return(all_KLR2)
  }

output_list[[i]] <- cats_output


}

save(output_list, file = "data/processed/Bio_exp_cats_output.RData")

```


